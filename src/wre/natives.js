export default {
  runtime: {
    isInteractive$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
  },

  Exception: {
    getFullStackTrace$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    getStackTrace$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
  },

  Object: {
    identity$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    instanceVariables$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    resolve$1(name) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    kindName$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    className$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
  },

  Set: {
    anyOne$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    fold$2(initialValue, closure) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    findOrElse$2(predicate, continuation) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    add$1(element) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    remove$1(element) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    size$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    clear$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    join$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    join$1(separator) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    equals$1(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '==$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
  },

  List: {
    get$1(index) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    sortBy$1(closure) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    fold$2(initialValue, closure) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    findOrElse$2(predicate, continuation) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    add$1(element) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    remove$1(element) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    size$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    clear$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    join$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    join$1(separator) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    equals$1(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '==$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
  },

  Dictionary: {
    put$2(_key, _value) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    basicGet$1(_key) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    remove$1(_key) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    keys$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    values$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    forEach$1(closure) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    clear$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
  },

  Integer: {
    '===$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '+$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '-$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '*$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '/$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '**$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '%$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    div$1(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    toString$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    stringValue$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '>$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '>=$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '<$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '<=$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    abs$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    invert$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    gcd$1(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    randomUpTo$1(max) { /* TODO:*/ throw new ReferenceError('To be implemented') },
  },
  Double: {
    '===$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '+$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '-$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '*$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '/$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '**$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '%$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    div$1(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    stringValue$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '>$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '>=$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '<$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '<=$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    abs$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    invert$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    gcd$1(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    randomUpTo$1(max) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    roundUp$1(_decimals) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    truncate$1(_decimals) { /* TODO:*/ throw new ReferenceError('To be implemented') },
  },

  String: {
    length$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    charAt$1(index) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '+$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    startsWith$1(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    endsWith$1(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    indexOf$1(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    lastIndexOf$1(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    toLowerCase$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    toUpperCase$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    trim$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '<$1'(aString) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '>$1'(aString) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    contains$1(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    substring$1(length) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    substring$2(startIndex, length) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    replace$2(expression, replacement) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    toString$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    toSmartString$1(alreadyShown) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '==$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
  },

  Boolean: {
    and$1(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '&&$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    or$1(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '||$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    toString$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    toSmartString$1(alreadyShown) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '==$1'(other) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    negate$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
  },

  Range: {
    validate$1(_limit) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    forEach$1(closure) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    anyOne$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
  },

  Closure: {
    'apply$0+'(...parameters) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    toString$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
  },

  Date: {
    toString$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '==$1'(_aDate) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    plusDays$1(_days) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    plusMonths$1(_months) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    plusYears$1(_years) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    isLeapYear$1() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    initialize$3(_day, _month, _year) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    day$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    dayOfWeek$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    month$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    year$0() { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '-$1'(_aDate) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    minusDays$1(_days) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    minusMonths$1(_months) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    minusYears$1(_years) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '<$1'(_aDate) { /* TODO:*/ throw new ReferenceError('To be implemented') },
    '>$1'(_aDate) { /* TODO:*/ throw new ReferenceError('To be implemented') },
  }
}